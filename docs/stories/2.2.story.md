# Story 2.2: Text Injection at Cursor

## Status

Draft

## Story

**As a** user,
**I want** transcribed text to appear where my cursor is,
**so that** I can dictate directly into any text field or document.

## Acceptance Criteria

1. Platform-specific text injection implemented:
   - Windows: `SendInput` API for keystrokes
   - macOS: `CGEvent` for keystroke simulation
   - Linux: `xdotool` or `ydotool` (Wayland) subprocess
2. Tauri command `inject_text(text: String)` exposed to frontend
3. Text injection works in common apps: browser, text editor, terminal
4. Special characters and punctuation handled correctly
5. Unicode support (accented characters, emoji if spoken)
6. Configurable delay between keystrokes for compatibility with slow apps
7. Error handling for: no focused text field, permission issues

## Tasks / Subtasks

- [ ] **Task 1: Create Text Injection Trait** (AC: 1)
  - [ ] Create `src-tauri/src/services/platform/text_inject.rs`
  - [ ] Define `TextInjector` trait with `inject_text()` method
  - [ ] Add `supports_paste()` method
  - [ ] Add `get_permission_instructions()` method

- [ ] **Task 2: Implement Windows Text Injection** (AC: 1, 3, 4, 5)
  - [ ] Create `src-tauri/src/services/platform/windows.rs`
  - [ ] Use `arboard` crate for clipboard
  - [ ] Simulate Ctrl+V using `windows-rs` SendInput
  - [ ] Handle Unicode via clipboard

- [ ] **Task 3: Implement macOS Text Injection** (AC: 1, 3, 4, 5)
  - [ ] Create `src-tauri/src/services/platform/macos.rs`
  - [ ] Use `arboard` for clipboard
  - [ ] Simulate Cmd+V using `core-graphics` CGEvent
  - [ ] Handle Accessibility permission requirements

- [ ] **Task 4: Implement Linux Text Injection** (AC: 1, 3, 4, 5)
  - [ ] Create `src-tauri/src/services/platform/linux.rs`
  - [ ] Detect X11 vs Wayland display server
  - [ ] X11: Use `xdotool key ctrl+v`
  - [ ] Wayland: Use `ydotool key 29:1 47:1 47:0 29:0` (Ctrl+V keycodes)
  - [ ] Fallback to `wl-copy` + `wtype` if ydotool unavailable

- [ ] **Task 5: Implement Keystroke Delay** (AC: 6)
  - [ ] Add `injection_delay_ms` to Settings
  - [ ] Default: 0ms (instant)
  - [ ] Range: 0-50ms between keystrokes
  - [ ] Apply delay in injection methods

- [ ] **Task 6: Error Handling** (AC: 7)
  - [ ] Detect if no text field is focused (best effort)
  - [ ] Handle clipboard access errors
  - [ ] Handle permission denied (macOS Accessibility)
  - [ ] Return user-friendly error messages

- [ ] **Task 7: Create Tauri Command** (AC: 2)
  - [ ] `inject_text(text: String)` command
  - [ ] Access platform-specific injector via AppState
  - [ ] Handle errors and return Result

- [ ] **Task 8: Add Integration Tests**
  - [ ] Test clipboard operations
  - [ ] Test Unicode handling
  - [ ] Manual testing matrix for common apps

## Dev Notes

### Dependencies [Source: architecture.md#2.3]

```toml
# src-tauri/Cargo.toml
[dependencies]
arboard = "3"

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.52", features = ["Win32_UI_Input_KeyboardAndMouse"] }

[target.'cfg(target_os = "macos")'.dependencies]
core-graphics = "0.23"
core-foundation = "0.9"
```

### TextInjector Trait [Source: architecture.md#8.1]

```rust
// src-tauri/src/services/platform/text_inject.rs
pub trait TextInjector: Send + Sync {
    /// Inject text into the currently focused application
    fn inject_text(&self, text: &str) -> Result<(), PlatformError>;

    /// Check if this platform supports clipboard-based injection
    fn supports_paste(&self) -> bool { true }

    /// Get platform-specific instructions for accessibility permissions
    fn get_permission_instructions(&self) -> Option<String> { None }
}
```

### Windows Implementation [Source: architecture.md#8.2]

```rust
// src-tauri/src/services/platform/windows.rs
#[cfg(target_os = "windows")]
use windows::Win32::UI::Input::KeyboardAndMouse::{
    SendInput, INPUT, INPUT_KEYBOARD, KEYBDINPUT, KEYEVENTF_KEYUP, VK_CONTROL, VK_V,
};

#[cfg(target_os = "windows")]
pub struct WindowsTextInjector {
    delay_ms: u32,
}

#[cfg(target_os = "windows")]
impl TextInjector for WindowsTextInjector {
    fn inject_text(&self, text: &str) -> Result<(), PlatformError> {
        // Copy to clipboard
        let mut clipboard = arboard::Clipboard::new()?;
        clipboard.set_text(text)?;

        // Small delay for clipboard to update
        std::thread::sleep(std::time::Duration::from_millis(50));

        // Simulate Ctrl+V
        unsafe {
            let inputs = [
                create_key_input(VK_CONTROL, false),
                create_key_input(VK_V, false),
                create_key_input(VK_V, true),
                create_key_input(VK_CONTROL, true),
            ];
            SendInput(&inputs, std::mem::size_of::<INPUT>() as i32);
        }

        Ok(())
    }
}
```

### macOS Implementation [Source: architecture.md#8.3]

```rust
// src-tauri/src/services/platform/macos.rs
#[cfg(target_os = "macos")]
use core_graphics::event::{CGEvent, CGEventFlags, CGEventTapLocation};
use core_graphics::event_source::{CGEventSource, CGEventSourceStateID};

#[cfg(target_os = "macos")]
pub struct MacOSTextInjector {
    delay_ms: u32,
}

#[cfg(target_os = "macos")]
impl TextInjector for MacOSTextInjector {
    fn inject_text(&self, text: &str) -> Result<(), PlatformError> {
        // Copy to clipboard
        let mut clipboard = arboard::Clipboard::new()?;
        clipboard.set_text(text)?;

        std::thread::sleep(std::time::Duration::from_millis(50));

        // Simulate Cmd+V
        let source = CGEventSource::new(CGEventSourceStateID::HIDSystemState)
            .map_err(|_| PlatformError::EventSourceError)?;

        let cmd_down = CGEvent::new_keyboard_event(source.clone(), 0x37, true)?;
        let v_down = CGEvent::new_keyboard_event(source.clone(), 0x09, true)?;
        let v_up = CGEvent::new_keyboard_event(source.clone(), 0x09, false)?;
        let cmd_up = CGEvent::new_keyboard_event(source, 0x37, false)?;

        cmd_down.set_flags(CGEventFlags::CGEventFlagCommand);
        v_down.set_flags(CGEventFlags::CGEventFlagCommand);

        cmd_down.post(CGEventTapLocation::HID);
        v_down.post(CGEventTapLocation::HID);
        v_up.post(CGEventTapLocation::HID);
        cmd_up.post(CGEventTapLocation::HID);

        Ok(())
    }

    fn get_permission_instructions(&self) -> Option<String> {
        Some("Grant Accessibility permissions: System Preferences > Security & Privacy > Privacy > Accessibility".into())
    }
}
```

### Linux Implementation [Source: architecture.md#8.4]

```rust
// src-tauri/src/services/platform/linux.rs
#[cfg(target_os = "linux")]
pub struct LinuxTextInjector {
    display_server: DisplayServer,
    delay_ms: u32,
}

#[cfg(target_os = "linux")]
enum DisplayServer {
    X11,
    Wayland,
}

#[cfg(target_os = "linux")]
impl LinuxTextInjector {
    pub fn new() -> Result<Self, PlatformError> {
        let display_server = if std::env::var("WAYLAND_DISPLAY").is_ok() {
            DisplayServer::Wayland
        } else {
            DisplayServer::X11
        };
        Ok(Self { display_server, delay_ms: 0 })
    }
}

#[cfg(target_os = "linux")]
impl TextInjector for LinuxTextInjector {
    fn inject_text(&self, text: &str) -> Result<(), PlatformError> {
        let mut clipboard = arboard::Clipboard::new()?;
        clipboard.set_text(text)?;

        std::thread::sleep(std::time::Duration::from_millis(50));

        match self.display_server {
            DisplayServer::X11 => {
                std::process::Command::new("xdotool")
                    .args(["key", "ctrl+v"])
                    .status()
                    .map_err(|e| PlatformError::CommandFailed(e.to_string()))?;
            }
            DisplayServer::Wayland => {
                // ydotool keycodes: 29=Ctrl, 47=V
                std::process::Command::new("ydotool")
                    .args(["key", "29:1", "47:1", "47:0", "29:0"])
                    .status()
                    .map_err(|e| PlatformError::CommandFailed(e.to_string()))?;
            }
        }
        Ok(())
    }
}
```

### Tauri Command

```rust
// src-tauri/src/commands/transcription.rs
#[tauri::command]
pub async fn inject_text(
    text: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.text_injector
        .inject_text(&text)
        .map_err(|e| e.to_string())
}
```

### File Locations

| File | Purpose |
|------|---------|
| `src-tauri/src/services/platform/text_inject.rs` | TextInjector trait |
| `src-tauri/src/services/platform/windows.rs` | Windows implementation |
| `src-tauri/src/services/platform/macos.rs` | macOS implementation |
| `src-tauri/src/services/platform/linux.rs` | Linux implementation |

### Error Types

```rust
#[derive(Error, Debug)]
pub enum PlatformError {
    #[error("Clipboard error: {0}")]
    Clipboard(#[from] arboard::Error),

    #[error("Failed to create event source")]
    EventSourceError,

    #[error("Command failed: {0}")]
    CommandFailed(String),

    #[error("Permission denied: {0}")]
    PermissionDenied(String),
}
```

### Testing

**Manual Testing Matrix**:

| App | Windows | macOS | Linux X11 | Linux Wayland |
|-----|---------|-------|-----------|---------------|
| VS Code | | | | |
| Chrome | | | | |
| Terminal | | | | |
| Notepad/TextEdit | | | | |
| Slack | | | | |

**Test Scenarios**:
- Plain text injection
- Text with special characters (!@#$%^&*())
- Unicode characters (é, ñ, 中文)
- Multi-line text
- Empty string (should not crash)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 0.1 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

---

## QA Results
*To be filled by QA agent*
