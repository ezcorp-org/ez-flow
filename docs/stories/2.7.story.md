# Story 2.7: Transcription History

## Status

Draft

## Story

**As a** user,
**I want** to view my past transcriptions,
**so that** I can copy or reference text I dictated earlier.

## Acceptance Criteria

1. History view accessible from tray menu "History..."
2. Shows list of transcriptions: timestamp, preview (first 50 chars), duration
3. Clicking entry expands to show full text
4. Copy button copies full text to clipboard
5. Delete button removes individual entries
6. "Clear All History" with confirmation
7. History stored locally (SQLite via Tauri or JSON file)
8. History limit: 100 entries (oldest auto-deleted), configurable in settings
9. Search/filter functionality for finding past transcriptions

## Tasks / Subtasks

- [ ] **Task 1: Create History Database** (AC: 7)
  - [ ] Add `rusqlite` to dependencies
  - [ ] Create `src-tauri/src/services/storage/database.rs`
  - [ ] Create history table schema
  - [ ] Initialize database on app startup

- [ ] **Task 2: Define History Entry Model** (AC: 2)
  - [ ] Create `src-tauri/src/models/history.rs`
  - [ ] Define `HistoryEntry` struct
  - [ ] Add fields: id, text, timestamp, duration_ms, model_id, language

- [ ] **Task 3: Implement History Storage** (AC: 7, 8)
  - [ ] Create save_transcription() function
  - [ ] Create get_history() function with pagination
  - [ ] Implement auto-pruning to 100 entries
  - [ ] Make limit configurable in settings

- [ ] **Task 4: Create History Window** (AC: 1)
  - [ ] Add "History..." to tray menu
  - [ ] Create new Tauri window for history
  - [ ] Create `src/routes/history/+page.svelte`

- [ ] **Task 5: Create History List Component** (AC: 2)
  - [ ] Create `src/lib/components/HistoryList.svelte`
  - [ ] Display list with timestamp, preview, duration
  - [ ] Group by date (Today, Yesterday, This Week, etc.)
  - [ ] Virtual scrolling for performance

- [ ] **Task 6: Implement Expandable Entries** (AC: 3)
  - [ ] Click to expand/collapse full text
  - [ ] Smooth expand animation
  - [ ] Only one expanded at a time (accordion)

- [ ] **Task 7: Implement Copy Button** (AC: 4)
  - [ ] Add copy button to each entry
  - [ ] Copy full text to clipboard
  - [ ] Show "Copied!" feedback

- [ ] **Task 8: Implement Delete Button** (AC: 5)
  - [ ] Add delete button to each entry
  - [ ] Confirm before deleting (optional)
  - [ ] Remove from database and UI

- [ ] **Task 9: Implement Clear All** (AC: 6)
  - [ ] Add "Clear All History" button
  - [ ] Show confirmation dialog
  - [ ] Delete all entries from database
  - [ ] Update UI

- [ ] **Task 10: Implement Search/Filter** (AC: 9)
  - [ ] Add search input at top
  - [ ] Filter results as user types
  - [ ] Highlight matching text
  - [ ] Search across full text content

- [ ] **Task 11: Create Tauri Commands**
  - [ ] `get_history(limit, offset)` - Paginated history
  - [ ] `delete_history_entry(id)` - Delete single entry
  - [ ] `clear_history()` - Delete all entries
  - [ ] `search_history(query)` - Search entries

- [ ] **Task 12: Add E2E Tests**
  - [ ] Test history displays entries
  - [ ] Test expand/collapse
  - [ ] Test copy functionality
  - [ ] Test delete functionality
  - [ ] Test search

## Dev Notes

### Dependencies

```toml
# src-tauri/Cargo.toml
[dependencies]
rusqlite = { version = "0.31", features = ["bundled"] }
```

### Database Schema

```rust
// src-tauri/src/services/storage/database.rs
use rusqlite::{Connection, Result};

const CREATE_TABLE: &str = r#"
    CREATE TABLE IF NOT EXISTS history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        duration_ms INTEGER NOT NULL,
        model_id TEXT NOT NULL,
        language TEXT,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_history_timestamp ON history(timestamp DESC);
    CREATE VIRTUAL TABLE IF NOT EXISTS history_fts USING fts5(text, content='history', content_rowid='id');
"#;

pub fn init_database(path: &Path) -> Result<Connection> {
    let conn = Connection::open(path)?;
    conn.execute_batch(CREATE_TABLE)?;
    Ok(conn)
}
```

### History Entry Model

```rust
// src-tauri/src/models/history.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryEntry {
    pub id: i64,
    pub text: String,
    pub timestamp: String,  // ISO 8601
    pub duration_ms: u64,
    pub model_id: String,
    pub language: Option<String>,
}

impl HistoryEntry {
    pub fn preview(&self, max_len: usize) -> String {
        if self.text.len() <= max_len {
            self.text.clone()
        } else {
            format!("{}...", &self.text[..max_len])
        }
    }
}
```

### History Service

```rust
// src-tauri/src/services/storage/history.rs

pub async fn save_transcription(
    db: &Database,
    result: &TranscriptionResult,
) -> Result<i64, DbError> {
    let entry = HistoryEntry {
        id: 0,
        text: result.text.clone(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        duration_ms: result.duration_ms,
        model_id: result.model_id.clone(),
        language: result.language.clone(),
    };

    let id = db.insert_history(&entry)?;

    // Prune old entries
    db.prune_history(100)?;

    Ok(id)
}

pub async fn get_history(
    db: &Database,
    limit: usize,
    offset: usize,
) -> Result<Vec<HistoryEntry>, DbError> {
    db.query_history(limit, offset)
}

pub async fn search_history(
    db: &Database,
    query: &str,
) -> Result<Vec<HistoryEntry>, DbError> {
    db.search_history_fts(query)
}
```

### History List Component

```svelte
<!-- src/lib/components/HistoryList.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { invoke } from '@tauri-apps/api/core';
  import { writeText } from '@tauri-apps/plugin-clipboard-manager';

  interface HistoryEntry {
    id: number;
    text: string;
    timestamp: string;
    duration_ms: number;
    model_id: string;
  }

  let entries: HistoryEntry[] = [];
  let expandedId: number | null = null;
  let searchQuery = '';
  let copiedId: number | null = null;

  onMount(async () => {
    entries = await invoke('get_history', { limit: 100, offset: 0 });
  });

  async function search() {
    if (searchQuery) {
      entries = await invoke('search_history', { query: searchQuery });
    } else {
      entries = await invoke('get_history', { limit: 100, offset: 0 });
    }
  }

  async function copyEntry(entry: HistoryEntry) {
    await writeText(entry.text);
    copiedId = entry.id;
    setTimeout(() => copiedId = null, 2000);
  }

  async function deleteEntry(id: number) {
    await invoke('delete_history_entry', { id });
    entries = entries.filter(e => e.id !== id);
  }

  async function clearAll() {
    if (confirm('Delete all transcription history? This cannot be undone.')) {
      await invoke('clear_history');
      entries = [];
    }
  }

  function formatDate(timestamp: string): string {
    return new Date(timestamp).toLocaleString();
  }

  function formatDuration(ms: number): string {
    const secs = Math.round(ms / 1000);
    return `${secs}s`;
  }
</script>

<div class="p-4">
  <!-- Search -->
  <div class="mb-4 flex gap-2">
    <input
      type="text"
      bind:value={searchQuery}
      on:input={search}
      placeholder="Search transcriptions..."
      class="flex-1 bg-neutral-800 rounded px-3 py-2"
    />
    <button
      class="px-4 py-2 bg-red-900/50 text-red-400 rounded"
      on:click={clearAll}
    >
      Clear All
    </button>
  </div>

  <!-- Entries -->
  <div class="space-y-2">
    {#each entries as entry (entry.id)}
      <div class="bg-neutral-800 rounded-lg overflow-hidden">
        <button
          class="w-full p-4 text-left flex justify-between items-start"
          on:click={() => expandedId = expandedId === entry.id ? null : entry.id}
        >
          <div>
            <p class="text-sm text-neutral-400">{formatDate(entry.timestamp)}</p>
            <p class="mt-1 text-neutral-200">
              {expandedId === entry.id ? entry.text : entry.text.slice(0, 50) + (entry.text.length > 50 ? '...' : '')}
            </p>
          </div>
          <span class="text-xs text-neutral-500">{formatDuration(entry.duration_ms)}</span>
        </button>

        {#if expandedId === entry.id}
          <div class="px-4 pb-4 flex gap-2">
            <button
              class="px-3 py-1 bg-yellow-400 text-black rounded text-sm"
              on:click={() => copyEntry(entry)}
            >
              {copiedId === entry.id ? 'Copied!' : 'Copy'}
            </button>
            <button
              class="px-3 py-1 bg-neutral-700 rounded text-sm"
              on:click={() => deleteEntry(entry.id)}
            >
              Delete
            </button>
          </div>
        {/if}
      </div>
    {/each}

    {#if entries.length === 0}
      <p class="text-center text-neutral-500 py-8">No transcriptions yet</p>
    {/if}
  </div>
</div>
```

### File Locations

| File | Purpose |
|------|---------|
| `src/routes/history/+page.svelte` | History page |
| `src/lib/components/HistoryList.svelte` | History list |
| `src-tauri/src/models/history.rs` | History model |
| `src-tauri/src/services/storage/database.rs` | SQLite setup |
| `src-tauri/src/services/storage/history.rs` | History operations |
| `src-tauri/src/commands/history.rs` | Tauri commands |

### Testing

**E2E Tests**:
```typescript
test('should display history entries', async ({ page }) => {
  // Create some transcriptions first...
  await page.click('[data-testid="tray-history"]');

  const entries = page.locator('[data-testid="history-entry"]');
  await expect(entries).toHaveCount.greaterThan(0);
});

test('should expand entry on click', async ({ page }) => {
  await page.click('[data-testid="history-entry"]:first-child');
  await expect(page.locator('[data-testid="entry-full-text"]')).toBeVisible();
});

test('should copy entry text', async ({ page }) => {
  await page.click('[data-testid="history-entry"]:first-child');
  await page.click('[data-testid="copy-entry-btn"]');
  await expect(page.locator('[data-testid="copy-entry-btn"]')).toHaveText('Copied!');
});

test('should search history', async ({ page }) => {
  await page.fill('[data-testid="history-search"]', 'hello');
  const entries = page.locator('[data-testid="history-entry"]');
  // Verify filtered results
});
```

**Test IDs**:
```typescript
const testIds = {
  historyPanel: 'history-panel',
  historyEntry: 'history-entry',
  historySearch: 'history-search',
  entryFullText: 'entry-full-text',
  copyEntryBtn: 'copy-entry-btn',
  deleteEntryBtn: 'delete-entry-btn',
  clearAllBtn: 'clear-all-btn',
};
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 0.1 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

---

## QA Results
*To be filled by QA agent*
