# Story 3.4: Multi-Language Support

## Status

Ready

## Story

**As a** user who speaks multiple languages,
**I want** to transcribe speech in my preferred language,
**so that** I can use EZ Flow for non-English dictation.

## Acceptance Criteria

1. Language selector in Settings with all Whisper-supported languages (99+)
2. "Auto-detect" option as default (Whisper determines language)
3. Selected language passed to Whisper inference
4. Language preference persisted per-session or globally (user choice)
5. Common languages surfaced at top of list (English, Spanish, Chinese, etc.)
6. Language displayed in transcription history entry
7. CLI supports `--language` flag

## Tasks / Subtasks

- [ ] **Task 1: Create Language Manifest** (AC: 1)
  - [ ] Create language list with codes and names
  - [ ] Include all 99+ Whisper languages
  - [ ] Add native names where applicable
  - [ ] Mark common languages for priority sorting

- [ ] **Task 2: Implement Language Selection UI** (AC: 1, 5)
  - [ ] Create `src/lib/components/LanguageSelector.svelte`
  - [ ] Show searchable dropdown
  - [ ] Group: Common languages at top
  - [ ] Show language in native script if available

- [ ] **Task 3: Update Settings Model** (AC: 2, 4)
  - [ ] Add `language: Option<String>` field
  - [ ] None = auto-detect
  - [ ] Persist in settings file

- [ ] **Task 4: Pass Language to Whisper** (AC: 3)
  - [ ] Update transcription engine
  - [ ] Set language in FullParams
  - [ ] Handle auto-detect case (None)

- [ ] **Task 5: Display in History** (AC: 6)
  - [ ] Add `language` field to HistoryEntry
  - [ ] Store detected/used language
  - [ ] Display in history list
  - [ ] Show language flag/code

- [ ] **Task 6: Update CLI** (AC: 7)
  - [ ] Add --language flag (existing from 3.3)
  - [ ] Validate language code
  - [ ] Include in JSON output

- [ ] **Task 7: Add Tests**
  - [ ] Test language selection persists
  - [ ] Test language passed to Whisper
  - [ ] Test auto-detect works

## Dev Notes

### Whisper Supported Languages

```rust
// src-tauri/src/services/transcription/languages.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Language {
    pub code: &'static str,
    pub name: &'static str,
    pub native_name: Option<&'static str>,
    pub common: bool,
}

pub const LANGUAGES: &[Language] = &[
    Language { code: "en", name: "English", native_name: None, common: true },
    Language { code: "es", name: "Spanish", native_name: Some("Español"), common: true },
    Language { code: "zh", name: "Chinese", native_name: Some("中文"), common: true },
    Language { code: "de", name: "German", native_name: Some("Deutsch"), common: true },
    Language { code: "fr", name: "French", native_name: Some("Français"), common: true },
    Language { code: "ja", name: "Japanese", native_name: Some("日本語"), common: true },
    Language { code: "ko", name: "Korean", native_name: Some("한국어"), common: true },
    Language { code: "pt", name: "Portuguese", native_name: Some("Português"), common: true },
    Language { code: "ru", name: "Russian", native_name: Some("Русский"), common: true },
    Language { code: "ar", name: "Arabic", native_name: Some("العربية"), common: true },
    Language { code: "hi", name: "Hindi", native_name: Some("हिन्दी"), common: true },
    Language { code: "it", name: "Italian", native_name: Some("Italiano"), common: true },
    // ... 87 more languages
    Language { code: "af", name: "Afrikaans", native_name: None, common: false },
    Language { code: "sq", name: "Albanian", native_name: Some("Shqip"), common: false },
    // etc.
];

pub fn get_languages() -> Vec<Language> {
    let mut langs: Vec<_> = LANGUAGES.iter().cloned().collect();
    langs.sort_by(|a, b| {
        // Common languages first, then alphabetical
        b.common.cmp(&a.common).then(a.name.cmp(b.name))
    });
    langs
}
```

### Language Selector Component

```svelte
<!-- src/lib/components/LanguageSelector.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { invoke } from '@tauri-apps/api/core';

  interface Language {
    code: string;
    name: string;
    native_name: string | null;
    common: boolean;
  }

  export let value: string | null = null;

  let languages: Language[] = [];
  let search = '';
  let isOpen = false;

  onMount(async () => {
    languages = await invoke('get_languages');
  });

  $: filteredLanguages = languages.filter(lang =>
    lang.name.toLowerCase().includes(search.toLowerCase()) ||
    lang.code.toLowerCase().includes(search.toLowerCase()) ||
    (lang.native_name && lang.native_name.includes(search))
  );

  $: commonLanguages = filteredLanguages.filter(l => l.common);
  $: otherLanguages = filteredLanguages.filter(l => !l.common);

  function select(code: string | null) {
    value = code;
    isOpen = false;
    search = '';
  }

  function displayName(lang: Language): string {
    if (lang.native_name) {
      return `${lang.name} (${lang.native_name})`;
    }
    return lang.name;
  }
</script>

<div class="relative">
  <button
    class="w-full px-3 py-2 bg-neutral-800 rounded text-left flex justify-between items-center"
    on:click={() => isOpen = !isOpen}
  >
    <span>
      {#if value === null}
        Auto-detect
      {:else}
        {languages.find(l => l.code === value)?.name || value}
      {/if}
    </span>
    <span class="text-neutral-500">▼</span>
  </button>

  {#if isOpen}
    <div class="absolute z-10 mt-1 w-full bg-neutral-800 rounded shadow-lg max-h-64 overflow-y-auto">
      <input
        type="text"
        bind:value={search}
        placeholder="Search languages..."
        class="w-full px-3 py-2 bg-neutral-700 border-b border-neutral-600"
      />

      <button
        class="w-full px-3 py-2 text-left hover:bg-neutral-700"
        class:bg-neutral-700={value === null}
        on:click={() => select(null)}
      >
        Auto-detect
      </button>

      {#if commonLanguages.length > 0}
        <div class="px-3 py-1 text-xs text-neutral-500 uppercase">Common</div>
        {#each commonLanguages as lang}
          <button
            class="w-full px-3 py-2 text-left hover:bg-neutral-700"
            class:bg-neutral-700={value === lang.code}
            on:click={() => select(lang.code)}
          >
            {displayName(lang)}
          </button>
        {/each}
      {/if}

      {#if otherLanguages.length > 0}
        <div class="px-3 py-1 text-xs text-neutral-500 uppercase">All Languages</div>
        {#each otherLanguages as lang}
          <button
            class="w-full px-3 py-2 text-left hover:bg-neutral-700"
            class:bg-neutral-700={value === lang.code}
            on:click={() => select(lang.code)}
          >
            {displayName(lang)}
          </button>
        {/each}
      {/if}
    </div>
  {/if}
</div>
```

### Whisper Language Configuration

```rust
// src-tauri/src/services/transcription/engine.rs

impl WhisperEngine {
    pub fn transcribe(
        &self,
        audio: &[f32],
        language: Option<&str>,
    ) -> Result<TranscriptionResult, TranscriptionError> {
        let ctx = self.ctx.as_ref()
            .ok_or(TranscriptionError::ModelNotLoaded)?;

        let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });

        // Set language if specified, otherwise auto-detect
        params.set_language(language);

        // Disable translation (we want transcription)
        params.set_translate(false);

        let mut state = ctx.create_state()?;
        state.full(params, audio)?;

        // Get detected language if auto-detected
        let detected_language = state.full_lang_id()
            .map(|id| whisper_lang_str(id))
            .unwrap_or(language.map(|s| s.to_string()));

        let mut text = String::new();
        for i in 0..state.full_n_segments()? {
            text.push_str(&state.full_get_segment_text(i)?);
        }

        Ok(TranscriptionResult {
            text: text.trim().to_string(),
            duration_ms: (audio.len() as f32 / 16.0) as u64,
            model_id: self.model_id.clone(),
            language: detected_language,
        })
    }
}
```

### History Entry with Language

```rust
// src-tauri/src/models/history.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryEntry {
    pub id: i64,
    pub text: String,
    pub timestamp: String,
    pub duration_ms: u64,
    pub model_id: String,
    pub language: Option<String>,  // Added
}
```

### File Locations

| File | Purpose |
|------|---------|
| `src-tauri/src/services/transcription/languages.rs` | Language manifest |
| `src/lib/components/LanguageSelector.svelte` | Language dropdown |
| `src-tauri/src/commands/settings.rs` | Get languages command |

### Testing

**E2E Tests**:
```typescript
test('language selection persists', async ({ page }) => {
  await page.click('[data-testid="settings-btn"]');
  await page.click('[data-testid="language-selector"]');
  await page.click('[data-testid="language-option-es"]');

  // Reload
  await page.reload();

  await page.click('[data-testid="settings-btn"]');
  await expect(page.locator('[data-testid="language-selector"]')).toHaveText('Spanish');
});

test('transcription uses selected language', async ({ page }) => {
  // Set language to Spanish
  await setLanguage('es');

  // Record and transcribe Spanish audio
  // Verify result is Spanish
});
```

**Test IDs**:
```typescript
const testIds = {
  languageSelector: 'language-selector',
  languageSearch: 'language-search',
  languageOptionPrefix: 'language-option-', // + code
};
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 0.1 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

---

## QA Results
*To be filled by QA agent*
