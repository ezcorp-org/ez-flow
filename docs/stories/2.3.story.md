# Story 2.3: Push-to-Talk Complete Flow

## Status

Draft

## Story

**As a** user,
**I want** to hold the hotkey, speak, release, and see my words typed out,
**so that** I have a seamless hands-free dictation experience.

## Acceptance Criteria

1. Hotkey hold -> recording starts immediately
2. Hotkey release -> recording stops -> transcription runs -> text injected at cursor
3. Total latency from release to text appearing < 3 seconds (typical utterance)
4. Audio automatically discarded after successful transcription
5. If transcription fails, show error notification (not injected as text)
6. Works across window focus changes during recording
7. Cooldown prevents accidental double-triggers (500ms minimum between sessions)

## Tasks / Subtasks

- [ ] **Task 1: Wire Hotkey to Recording** (AC: 1, 2)
  - [ ] On hotkey press → call `start_recording()`
  - [ ] On hotkey release → call `stop_recording_and_transcribe()`
  - [ ] Connect events to state management

- [ ] **Task 2: Implement Text Injection After Transcription** (AC: 2)
  - [ ] Get transcription result
  - [ ] Call `inject_text()` with result text
  - [ ] Handle injection errors

- [ ] **Task 3: Implement Cooldown Prevention** (AC: 7)
  - [ ] Track last transcription completion time
  - [ ] Block new recording if < 500ms since last
  - [ ] Log blocked attempts
  - [ ] Make cooldown configurable in settings

- [ ] **Task 4: Optimize for Latency** (AC: 3)
  - [ ] Measure end-to-end latency
  - [ ] Minimize buffer sizes
  - [ ] Start transcription immediately on stop
  - [ ] Profile and optimize hot paths

- [ ] **Task 5: Handle Window Focus Changes** (AC: 6)
  - [ ] Recording should not stop on focus change
  - [ ] Text injection targets last focused text field
  - [ ] Test with window switching during recording

- [ ] **Task 6: Implement Error Notifications** (AC: 5)
  - [ ] Use system notifications for errors
  - [ ] Show toast/notification on transcription failure
  - [ ] Do not inject error message as text
  - [ ] Log errors with tracing

- [ ] **Task 7: Auto-Cleanup Audio** (AC: 4)
  - [ ] Delete temp audio file after successful transcription
  - [ ] Keep file on error for debugging (optional)
  - [ ] Clear audio buffer from memory

- [ ] **Task 8: Create End-to-End State Machine**
  - [ ] States: Idle → Recording → Transcribing → Injecting → Idle
  - [ ] Handle errors at each transition
  - [ ] Emit state change events to frontend

- [ ] **Task 9: Add Latency Metrics**
  - [ ] Track: recording_duration, transcription_time, injection_time
  - [ ] Log total end-to-end latency
  - [ ] Warn if > 3 seconds

- [ ] **Task 10: Add E2E Test**
  - [ ] Full push-to-talk flow test
  - [ ] Verify text appears in target field
  - [ ] Test cooldown behavior

## Dev Notes

### Dependencies on Previous Stories

This story integrates:
- **Story 2.1**: Global hotkey (press/release events)
- **Story 2.2**: Text injection (inject_text)
- **Story 1.7**: Record & transcribe flow

### State Machine

```
┌───────┐  hotkey_pressed   ┌───────────┐
│ Idle  │─────────────────►│ Recording │
└───────┘                   └─────┬─────┘
    ▲                             │ hotkey_released
    │                             ▼
    │                       ┌─────────────┐
    │      error            │Transcribing │
    │◄──────────────────────┤             │
    │                       └─────┬───────┘
    │                             │ success
    │                             ▼
    │                       ┌───────────┐
    │      done             │ Injecting │
    └───────────────────────┤           │
                            └───────────┘
```

### Hotkey Event Handler

```rust
// src-tauri/src/services/platform/hotkey.rs
pub fn setup_push_to_talk(app: &AppHandle) -> Result<(), HotkeyError> {
    let state = app.state::<AppState>();
    let cooldown = Arc::new(RwLock::new(std::time::Instant::now()));

    app.global_shortcut().on_shortcut(
        HotkeyService::get_default_hotkey(),
        move |app, _shortcut, event| {
            let state = app.state::<AppState>();
            let cooldown = cooldown.clone();

            match event.state {
                ShortcutState::Pressed => {
                    // Check cooldown
                    let last = *cooldown.blocking_read();
                    if last.elapsed() < Duration::from_millis(500) {
                        tracing::debug!("Ignoring hotkey - cooldown active");
                        return;
                    }

                    // Start recording
                    tauri::async_runtime::spawn(async move {
                        if let Err(e) = start_recording_async(&state).await {
                            tracing::error!("Failed to start recording: {}", e);
                        }
                    });
                }
                ShortcutState::Released => {
                    // Stop, transcribe, inject
                    let cooldown = cooldown.clone();
                    tauri::async_runtime::spawn(async move {
                        match stop_transcribe_inject(&state).await {
                            Ok(_) => {
                                *cooldown.write().await = std::time::Instant::now();
                            }
                            Err(e) => {
                                show_error_notification(&e);
                            }
                        }
                    });
                }
            }
        }
    )?;

    Ok(())
}
```

### Complete Flow Function

```rust
async fn stop_transcribe_inject(state: &AppState) -> Result<(), AppError> {
    let start = std::time::Instant::now();

    // Stop recording
    let mut capture = state.audio_capture.write().await;
    let audio = capture.stop()?;
    let recording_duration = audio.samples.len() as f32 / 16000.0;

    // Resample
    let samples = resample_for_whisper(audio)?;

    // Transcribe
    let transcribe_start = std::time::Instant::now();
    let engine = state.transcription_engine.read().await;
    let result = engine.transcribe(&samples)?;
    let transcription_time = transcribe_start.elapsed();

    // Inject text
    let inject_start = std::time::Instant::now();
    state.text_injector.inject_text(&result.text)?;
    let injection_time = inject_start.elapsed();

    let total_latency = start.elapsed();

    tracing::info!(
        recording_duration_secs = recording_duration,
        transcription_time_ms = transcription_time.as_millis(),
        injection_time_ms = injection_time.as_millis(),
        total_latency_ms = total_latency.as_millis(),
        text_length = result.text.len(),
        "Push-to-talk flow completed"
    );

    if total_latency.as_secs() > 3 {
        tracing::warn!("Latency exceeded 3 second target");
    }

    Ok(())
}
```

### Error Notification

```rust
use tauri::api::notification::Notification;

fn show_error_notification(error: &AppError) {
    let _ = Notification::new("com.ezflow.app")
        .title("Transcription Failed")
        .body(&error.to_string())
        .show();
}
```

### Latency Budget

| Phase | Target | Notes |
|-------|--------|-------|
| Audio stop + buffer | < 50ms | Memory operations |
| Resampling | < 100ms | CPU-bound |
| Transcription | < 2500ms | Model-dependent |
| Text injection | < 100ms | OS interaction |
| **Total** | **< 3000ms** | For ~5 second utterance |

### File Locations

| File | Purpose |
|------|---------|
| `src-tauri/src/services/platform/hotkey.rs` | Push-to-talk setup |
| `src-tauri/src/services/workflow.rs` | Complete flow logic |

### Testing

**E2E Test**:
```typescript
test('push-to-talk complete flow', async ({ page }) => {
  // Focus a text input
  await page.click('[data-testid="test-input"]');

  // Simulate hotkey press (requires native integration)
  await simulateHotkeyPress();

  // Wait for recording indicator
  await expect(page.locator('[data-testid="recording-indicator"]')).toBeVisible();

  // Wait for speech (mocked)
  await page.waitForTimeout(2000);

  // Simulate hotkey release
  await simulateHotkeyRelease();

  // Wait for text to appear
  await expect(page.locator('[data-testid="test-input"]')).toHaveValue(/hello/i, { timeout: 5000 });
});
```

**Test Scenarios**:
- Normal push-to-talk flow
- Rapid double-press (should be blocked by cooldown)
- Window focus change during recording
- Transcription failure handling
- Very short recording (< 0.5s)
- Long recording (> 30s)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 0.1 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

---

## QA Results
*To be filled by QA agent*
