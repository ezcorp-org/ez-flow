# Story 3.3: CLI Interface

## Status

Draft

## Story

**As a** developer,
**I want** a command-line interface for EZ Flow,
**so that** I can integrate speech-to-text into scripts and automation.

## Acceptance Criteria

1. CLI binary: `ezflow` (separate from GUI or Tauri sidecar)
2. Commands:
   - `ezflow transcribe <audio_file>` - outputs text to stdout
   - `ezflow record` - records until Enter pressed, outputs transcription
   - `ezflow models list` - shows available/downloaded models
   - `ezflow models download <name>` - downloads specified model
   - `ezflow --version` and `ezflow --help`
3. Options: `--model <name>`, `--language <code>`, `--json` (structured output)
4. Exit codes: 0 success, 1 error, 2 invalid args
5. Works independently of GUI app running
6. Shares model directory with GUI app
7. Installable via package managers (documented for Homebrew, Scoop, apt)

## Tasks / Subtasks

- [ ] **Task 1: Create CLI Crate** (AC: 1)
  - [ ] Create `cli/` directory in monorepo
  - [ ] Initialize `cli/Cargo.toml`
  - [ ] Add to workspace in root `Cargo.toml`
  - [ ] Share core crates with Tauri app

- [ ] **Task 2: Add CLI Dependencies** (AC: 1)
  - [ ] Add `clap` for argument parsing
  - [ ] Add `indicatif` for progress bars
  - [ ] Share `whisper-rs`, `cpal`, etc. from core

- [ ] **Task 3: Implement Argument Parser** (AC: 2, 3)
  - [ ] Define CLI structure with clap
  - [ ] Add subcommands: transcribe, record, models
  - [ ] Add global options: --model, --language, --json
  - [ ] Add --version and --help

- [ ] **Task 4: Implement `transcribe` Command** (AC: 2)
  - [ ] Accept audio file path
  - [ ] Load audio file (use symphonia)
  - [ ] Resample to 16kHz mono
  - [ ] Run Whisper inference
  - [ ] Output text to stdout

- [ ] **Task 5: Implement `record` Command** (AC: 2)
  - [ ] Start recording with cpal
  - [ ] Wait for Enter key
  - [ ] Stop and transcribe
  - [ ] Output text to stdout

- [ ] **Task 6: Implement `models` Subcommands** (AC: 2)
  - [ ] `models list` - Show available models with download status
  - [ ] `models download <name>` - Download with progress bar
  - [ ] Share model manifest with GUI

- [ ] **Task 7: Implement JSON Output** (AC: 3)
  - [ ] Define JSON output structure
  - [ ] Add --json flag
  - [ ] Output structured JSON to stdout
  - [ ] Include metadata (duration, model, language)

- [ ] **Task 8: Implement Exit Codes** (AC: 4)
  - [ ] Return 0 on success
  - [ ] Return 1 on runtime error
  - [ ] Return 2 on invalid arguments
  - [ ] Document exit codes

- [ ] **Task 9: Share Model Directory** (AC: 5, 6)
  - [ ] Use same directories crate logic
  - [ ] Detect models from shared location
  - [ ] Work without GUI running

- [ ] **Task 10: Add Package Manager Docs** (AC: 7)
  - [ ] Document Homebrew formula (macOS)
  - [ ] Document Scoop manifest (Windows)
  - [ ] Document apt/deb (Linux)
  - [ ] Add to README

- [ ] **Task 11: Add Tests**
  - [ ] Test argument parsing
  - [ ] Test transcribe command
  - [ ] Test models list
  - [ ] Integration test with sample audio

## Dev Notes

### Project Structure

```
ez-flow/
├── cli/
│   ├── Cargo.toml
│   └── src/
│       ├── main.rs
│       ├── commands/
│       │   ├── mod.rs
│       │   ├── transcribe.rs
│       │   ├── record.rs
│       │   └── models.rs
│       └── output.rs
├── core/                    # Shared library
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
└── src-tauri/              # GUI app
```

### CLI Cargo.toml

```toml
# cli/Cargo.toml
[package]
name = "ezflow"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "ezflow"
path = "src/main.rs"

[dependencies]
clap = { version = "4", features = ["derive"] }
indicatif = "0.17"
anyhow = "1"
serde_json = "1"

# Shared with Tauri app
whisper-rs = "0.11"
cpal = "0.15"
symphonia = { version = "0.5", features = ["mp3", "aac", "ogg", "flac", "wav"] }
rubato = "0.14"
directories = "5"
```

### CLI Argument Structure

```rust
// cli/src/main.rs
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "ezflow")]
#[command(version, about = "Local speech-to-text transcription")]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Output format
    #[arg(long, global = true)]
    json: bool,

    /// Whisper model to use
    #[arg(long, global = true, default_value = "base")]
    model: String,

    /// Transcription language (auto-detect if not specified)
    #[arg(long, global = true)]
    language: Option<String>,
}

#[derive(Subcommand)]
enum Commands {
    /// Transcribe an audio file
    Transcribe {
        /// Path to audio file
        file: PathBuf,
    },

    /// Record from microphone and transcribe
    Record,

    /// Manage Whisper models
    Models {
        #[command(subcommand)]
        action: ModelsAction,
    },
}

#[derive(Subcommand)]
enum ModelsAction {
    /// List available models
    List,

    /// Download a model
    Download {
        /// Model name (tiny, base, small, medium, large-v3)
        name: String,
    },
}
```

### Transcribe Command Implementation

```rust
// cli/src/commands/transcribe.rs
use anyhow::Result;
use std::path::Path;

pub fn transcribe(
    file: &Path,
    model: &str,
    language: Option<&str>,
    json_output: bool,
) -> Result<()> {
    // Load model
    let model_path = get_model_path(model)?;
    let mut engine = WhisperEngine::new();
    engine.load_model(&model_path)?;

    // Load and process audio
    let audio = load_audio_file(file)?;
    let samples = resample_for_whisper(audio)?;

    // Transcribe
    let result = engine.transcribe(&samples, language)?;

    // Output
    if json_output {
        let output = serde_json::json!({
            "text": result.text,
            "duration_ms": result.duration_ms,
            "model": model,
            "language": result.language,
        });
        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        println!("{}", result.text);
    }

    Ok(())
}
```

### Record Command Implementation

```rust
// cli/src/commands/record.rs
use anyhow::Result;
use std::io::{self, Write};

pub fn record(model: &str, language: Option<&str>, json_output: bool) -> Result<()> {
    println!("Recording... Press Enter to stop.");
    io::stdout().flush()?;

    // Start recording
    let mut capture = AudioCaptureService::new()?;
    capture.start()?;

    // Wait for Enter
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;

    // Stop and transcribe
    let audio = capture.stop()?;
    let samples = resample_for_whisper(audio)?;

    let model_path = get_model_path(model)?;
    let mut engine = WhisperEngine::new();
    engine.load_model(&model_path)?;

    let result = engine.transcribe(&samples, language)?;

    // Output
    if json_output {
        let output = serde_json::json!({
            "text": result.text,
            "duration_ms": result.duration_ms,
        });
        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        println!("{}", result.text);
    }

    Ok(())
}
```

### Models Command Implementation

```rust
// cli/src/commands/models.rs
use indicatif::{ProgressBar, ProgressStyle};

pub fn list_models() -> Result<()> {
    let manifest = get_model_manifest();

    println!("{:<12} {:<20} {:>10} {}", "ID", "Name", "Size", "Status");
    println!("{}", "-".repeat(50));

    for model in manifest {
        let status = if is_model_downloaded(&model.id) {
            "Downloaded".green()
        } else {
            "Not downloaded".dimmed()
        };

        println!("{:<12} {:<20} {:>7} MB {}", model.id, model.name, model.size_mb, status);
    }

    Ok(())
}

pub fn download_model(name: &str) -> Result<()> {
    let manifest = get_model_manifest();
    let model = manifest.iter()
        .find(|m| m.id == name)
        .ok_or_else(|| anyhow!("Model '{}' not found", name))?;

    let pb = ProgressBar::new(100);
    pb.set_style(ProgressStyle::default_bar()
        .template("{msg} [{bar:40}] {percent}%")?);
    pb.set_message(format!("Downloading {}", model.name));

    download_model_with_progress(model, |progress| {
        pb.set_position((progress * 100.0) as u64);
    })?;

    pb.finish_with_message("Download complete");
    Ok(())
}
```

### Exit Codes

```rust
// cli/src/main.rs
fn main() {
    let result = run();

    std::process::exit(match result {
        Ok(_) => 0,
        Err(e) => {
            eprintln!("Error: {}", e);
            if e.to_string().contains("invalid") {
                2 // Invalid arguments
            } else {
                1 // Runtime error
            }
        }
    });
}
```

### File Locations

| File | Purpose |
|------|---------|
| `cli/src/main.rs` | CLI entry point |
| `cli/src/commands/transcribe.rs` | Transcribe command |
| `cli/src/commands/record.rs` | Record command |
| `cli/src/commands/models.rs` | Models management |
| `cli/src/output.rs` | Output formatting |

### Testing

**Test Scenarios**:
```rust
#[test]
fn test_transcribe_valid_file() {
    let output = Command::new("ezflow")
        .args(["transcribe", "tests/fixtures/hello.wav"])
        .output()
        .unwrap();

    assert!(output.status.success());
    assert!(String::from_utf8_lossy(&output.stdout).contains("hello"));
}

#[test]
fn test_invalid_file_returns_1() {
    let output = Command::new("ezflow")
        .args(["transcribe", "nonexistent.wav"])
        .output()
        .unwrap();

    assert_eq!(output.status.code(), Some(1));
}

#[test]
fn test_invalid_args_returns_2() {
    let output = Command::new("ezflow")
        .args(["invalid-command"])
        .output()
        .unwrap();

    assert_eq!(output.status.code(), Some(2));
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 0.1 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

---

## QA Results
*To be filled by QA agent*
